<!doctype html>
<html lang="ja" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Stephen Welch : なぜディープラーニングは驚くほどうまくいくのか | UFO/Bigfoot/Missing-411/Supernatural Research</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ume2509.github.io/ds/img/gh_docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ume2509.github.io/ds/img/gh_docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works"><meta data-rh="true" property="og:locale" content="ja"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="ja"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ja"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Stephen Welch : なぜディープラーニングは驚くほどうまくいくのか | UFO/Bigfoot/Missing-411/Supernatural Research"><meta data-rh="true" name="description" content="前置き"><meta data-rh="true" property="og:description" content="前置き"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2025-08-10T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="AI,2025-08"><link data-rh="true" rel="icon" href="/ds/img/gh_favicon.png"><link data-rh="true" rel="canonical" href="https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works"><link data-rh="true" rel="alternate" href="https://ume2509.github.io/ds/en/blog/2025/08/10/why_deep_learning_works" hreflang="en"><link data-rh="true" rel="alternate" href="https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works" hreflang="ja"><link data-rh="true" rel="alternate" href="https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works","mainEntityOfPage":"https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works","url":"https://ume2509.github.io/ds/blog/2025/08/10/why_deep_learning_works","headline":"Stephen Welch : なぜディープラーニングは驚くほどうまくいくのか","name":"Stephen Welch : なぜディープラーニングは驚くほどうまくいくのか","description":"前置き","datePublished":"2025-08-10T00:00:00.000Z","author":[],"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://ume2509.github.io/ds/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/ds/blog/rss.xml" title="UFO/Bigfoot/Missing-411/Supernatural Research RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ds/blog/atom.xml" title="UFO/Bigfoot/Missing-411/Supernatural Research Atom Feed"><link rel="stylesheet" href="/ds/assets/css/styles.23039daa.css">
<script src="/ds/assets/js/runtime~main.e42f3ede.js" defer="defer"></script>
<script src="/ds/assets/js/main.46d641bc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="メインコンテンツまでスキップ"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">メインコンテンツまでスキップ</a></div><nav aria-label="ナビゲーション" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="ナビゲーションバーを開く" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ds/"><div class="navbar__logo"><img src="/ds/img/gh_favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/ds/img/gh_favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">記事一覧</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/ds/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>日本語</a><ul class="dropdown__menu"><li><a href="/ds/en/blog/2025/08/10/why_deep_learning_works" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/ds/blog/2025/08/10/why_deep_learning_works" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ja">日本語</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="ダークモードを切り替える(現在はライトモード)" aria-label="ダークモードを切り替える(現在はライトモード)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近のブログ記事のナビゲーション"><div class="sidebarItemTitle_pO2u margin-bottom--md">Blog 最新記事</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/29/chp">Craig Hamilton-Parker の 2025-09 の予言</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/29/gary_baker">Gary Baker の証言 : 「レーダーが停止状態だった」という英国防省の主張は嘘だ</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/28/jared_m411">Missing-411 : Jared Negrete の事例 ⇒ この謎を推測する</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/28/why_cant_we_understand">「「理解」を理解できない理由」を否定的に理解する</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/27/mark_marinaccio">Mark Marinaccio : Skinwalker ranch で体験した異常現象</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/25/david_purcell">David Purcell の証言 : ET と  の遭遇と SSP（秘密宇宙プログラム）の体験</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/24/diana_pasulka">Diana Walsh Pasulka : UFO、テクノロジー、意識の関連性</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/24/scott_adams">Scott Adams : local AI によって携帯電話機から OS やアプリが消えるだろう</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/23/jim_semivan">Jim Semivan : 非人類知性は現実だが、政府の全面的情報公開には懐疑的</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/23/stargate">Uri Geller の証言: 機密解除された CIA 文書が彼の超能力を確認し、CIA の作戦にも参加</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/22/edward_mann">W. Edward Mann : Wilhelm Reich のオルゴン・エネルギーを語る</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/22/jeke_kobrin">Jake Kobrin : オカルトとUFO: 隠された繋がり</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/21/bii_uhouse">Bill Uhouse の証言 : J-Rod を語る</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/21/daryl_james">Daryl James の証言 : 月の流刑地、異星人とタイムトラベル</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ds/blog/2025/08/21/john_dee">John Dee の魔術 : Heptarchia Mystica（ヘプタルキア・ミスティカ）の解説</a></li></ul></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">Stephen Welch : なぜディープラーニングは驚くほどうまくいくのか</h1><div class="container_mt6G margin-vert--md"><time datetime="2025-08-10T00:00:00.000Z">2025年8月10日</time> · <!-- -->約85分</div></header><div id="__blog-post-container" class="markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="前置き">前置き<a href="#前置き" class="hash-link" aria-label="前置き への直接リンク" title="前置き への直接リンク">​</a></h2>
<p>深層学習に関する解説動画は無数にあるが、今回の動画は直感的な理解を促すものとなっている。つまり抽象度がそれほど高くないので理解した気になれる動画。</p>
<p>以下の要約内容をざっと頭に入れてから動画を見ると（英語の聴き取りができずとも）、納得できる筈。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="概要">概要<a href="#概要" class="hash-link" aria-label="概要 への直接リンク" title="概要 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>なぜディープラーニングは驚くほどうまくいくのか</p><p>このビデオは、‌<strong>‌深層学習‌</strong>‌がどのように機能するか、特に‌<strong>‌ニューラルネットワーク‌</strong>‌が複雑な境界線を学習する能力について詳しく説明しています。</p><p>‌<strong>‌ユニバーサル近似定理‌</strong>‌を導入し  、十分な数のニューロンがあれば、2層のネットワークがどんな連続関数でも表現できることを示していますが、実際には‌<strong>‌勾配降下法‌</strong>‌ではそのような解決策を見つけるのが難しい場合があります。</p><p>代わりに、より多くの層を持つ‌<strong>‌深いネットワーク‌</strong>‌が、少ないニューロン数でより複雑なパターンを学習できることが、‌<strong>‌ReLU活性化関数‌</strong>‌による層ごとの幾何学的変換を通じて解説されています。また、このビデオは‌<strong>‌Welch Labs‌</strong>‌という教育コンテンツ作成者の個人史と、その活動の資金調達の課題についても触れています。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="目次">目次<a href="#目次" class="hash-link" aria-label="目次 への直接リンク" title="目次 への直接リンク">​</a></h2>
<ol>
<li>
<a href="#前置き">前置き</a>
</li>
<li>
<a href="#概要">概要</a>
</li>
<li>
<a href="#音声対話">音声対話</a>
</li>
<li>
<a href="#詳細">詳細</a>
<ol>
<li>
<a href="#1-ユニバーサル近似定理とその限界">1. ユニバーサル近似定理とその限界</a>
</li>
<li>
<a href="#2-深層ネットワークの優位性">2. 深層ネットワークの優位性</a>
</li>
<li>
<a href="#3-ニューラルネットワーク研究の進化と教育への貢献">3. ニューラルネットワーク研究の進化と教育への貢献</a>
</li>
<li>
<a href="#結論">結論</a>
</li>
</ol>
</li>
<li>
<a href="#普遍的近似定理">普遍的近似定理</a>
<ol>
<li>
<a href="#普遍的近似定理の定義とその保証">普遍的近似定理の定義とその保証</a>
</li>
<li>
<a href="#理論と実践のギャップ">理論と実践のギャップ</a>
</li>
<li>
<a href="#ディープネットワークの利点と効率性">ディープネットワークの利点と効率性</a>
</li>
</ol>
</li>
<li>
<a href="#ニューラルネットワークの幾何学的解釈">ニューラルネットワークの幾何学的解釈</a>
<ol>
<li>
<a href="#1-浅い2層ニューラルネットワークの幾何学的解釈">1. 浅い（2層）ニューラルネットワークの幾何学的解釈</a>
</li>
<li>
<a href="#2-深い多層ニューラルネットワークの幾何学的解釈">2. 深い（多層）ニューラルネットワークの幾何学的解釈</a>
</li>
</ol>
</li>
<li>
<a href="#浅いネットワークと深いネットワークの対比">浅いネットワークと深いネットワークの対比</a>
<ol>
<li>
<a href="#ワイドネットワーク浅い2層ニューラルネットワークの幾何学的解釈と限界">ワイドネットワーク（浅い2層ニューラルネットワーク）の幾何学的解釈と限界</a>
</li>
<li>
<a href="#ディープネットワーク多層ニューラルネットワークの幾何学的解釈と優位性">ディープネットワーク（多層ニューラルネットワーク）の幾何学的解釈と優位性</a>
</li>
<li>
<a href="#ワイドネットワークとディープネットワークの比較">ワイドネットワークとディープネットワークの比較</a>
</li>
</ol>
</li>
<li>
<a href="#学習プロセスと課題">学習プロセスと課題</a>
<ol>
<li>
<a href="#学習プロセス">学習プロセス</a>
</li>
<li>
<a href="#学習の課題と限界">学習の課題と限界</a>
</li>
</ol>
</li>
<li>
<a href="#情報源">情報源</a>
<ol>
<li>
<a href="#動画概要欄">動画概要欄</a>
</li>
</ol>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="音声対話">音声対話<a href="#音声対話" class="hash-link" aria-label="音声対話 への直接リンク" title="音声対話 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p><a href="https://notebooklm.google.com/notebook/58620fc4-bc6a-42de-b3bb-75083ae00a20/audio" target="_blank" rel="noopener noreferrer">https://notebooklm.google.com/notebook/58620fc4-bc6a-42de-b3bb-75083ae00a20/audio</a></p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="詳細">詳細<a href="#詳細" class="hash-link" aria-label="詳細 への直接リンク" title="詳細 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>ブリーフィングドキュメント：ディープラーニングが「不合理なほど」うまく機能する理由</p><p>このブリーフィングドキュメントは、提供されたソース「Why Deep Learning Works Unreasonably Well.en.txt」の主要テーマと最も重要なアイデアまたは事実をレビューすることを目的としています。特に、ニューラルネットワークが複雑な関数を近似し、深層ネットワークが浅いネットワークよりも効率的である理由に焦点を当てます。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-ユニバーサル近似定理とその限界">1. ユニバーサル近似定理とその限界<a href="#1-ユニバーサル近似定理とその限界" class="hash-link" aria-label="1. ユニバーサル近似定理とその限界 への直接リンク" title="1. ユニバーサル近似定理とその限界 への直接リンク">​</a></h3><ul>
<li>定理の内容: 1989年にジョージ・シバンコによって証明されたユニバーサル近似定理は、「複雑な関数、例えばベルギーとオランダの飛び地バールレ＝ヘルトフの非常に複雑な境界線を考えると、この定理は、この境界線を必要なだけ正確に近似できる2層ニューラルネットワークが存在することを保証します。」(0:00:24) この定理は、十分な数のニューロンを持つ「幅の広い」2層ネットワークが、いかなる連続関数でも表現できることを示唆しています。</li>
<li>幾何学的解釈: 2層ネットワークは、入力空間（この場合は地図）に「折り目」を作成することで機能します。各ニューロンは「単一の折り目に沿って地図のコピーを折りたたむ」ことができ(0:00:46)、これらが組み合わされてより複雑な表面が形成されます。最終的な出力ニューロンの表面の高さは、モデルの特定の地域がどちらかの国に属するという「確信度」に対応し、これらの表面の交点が「決定境界」を形成します(0:01:59)。</li>
<li>実践上の課題と限界:<!-- -->
<ul>
<li>広範なネットワークの非効率性: ソースは、100,000個のニューロンを持つ非常に「広い」ネットワークでも、バールレ＝ヘルトフの複雑な境界を完全に学習できないことを示しています(0:03:54)。これは、ユニバーサル近似定理が「広いニューラルネットワークはいかなる連続関数も表現できる能力がある」ことを意味するが、「実践において実際にその解決策を見つけることができる」とは限らないことを強調しています(0:14:33)。</li>
<li>勾配降下の制約: モデルの学習には、バックプロパゲーションと勾配降下法が用いられますが、これらのアルゴリズムは「最適な、あるいは良い解決策を見つけることを保証しない」と述べられています(0:15:10)。特定のランダムな初期化では、勾配がゼロになる（ReLU活性化関数のゼロ化された部分を通じて）ことで、モデルが最適ではない線形決定境界に「行き詰まる」ことがあります(0:18:06)。これは、特に浅いネットワークでは「高次元の損失ランドスケープで勾配降下法が局所最適解に陥る可能性が非常に低い」という一般的な認識にもかかわらず、発生し得ます(0:19:00)。</li>
<li>必要なニューロン数の不明確さ: 定理は「所与の問題を解決するために実際に必要なニューロンの数を教えてくれない」ため(0:19:00)、100,000個のニューロンでも不十分である可能性があります(0:19:22)。</li>
</ul>
</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-深層ネットワークの優位性">2. 深層ネットワークの優位性<a href="#2-深層ネットワークの優位性" class="hash-link" aria-label="2. 深層ネットワークの優位性 への直接リンク" title="2. 深層ネットワークの優位性 への直接リンク">​</a></h3><ul>
<li>驚異的な効率性: ソースの 核心的な発見は、ニューロンを複数層に配置する「深い」ネットワークの優位性です。「わずか130個のニューロンからなる5層ネットワークは、100,000個のニューロンからなるモデルよりも正確な境界線を学習することができ、地図をより効果的に分割することができます。」(0:04:24)</li>
<li>活性化関数の重要性: 層を追加するだけでは効果がなく、各層の間に活性化関数を導入する必要があります。特に‌<strong>‌ReLU（Rectified Linear Unit）‌</strong>‌が用いられます。「入力値が0未満の場合、ReLUは0を返します。そして、入力値が0以上の場合、ReLUはその入力値をそのまま通過させます。」(0:11:03) ReLU関数を適用することで、各ニューロンは単なる平面ではなく「曲がった平面」を出力し(0:11:42)、これが非線形変換を可能にします。</li>
<li>幾何学的な「折りたたみ」の連鎖: 深層ネットワークでは、各層が前の層によって生成された複雑な表面をさらに折りたたみ、スケーリングし、結合します。第1層では「直線的な折り目」が作成されますが、第2層では「もはや単純な平面ではない」表面が折りたたまれ、これにより「3つの異なる新しい折り目」が作成されます(0:21:31)。これらの折り目は単純な直線ではなく、「第1層から得られる平面の結合点で実際に曲がる」という複雑な幾何学的形状を持ちます(0:21:56)。</li>
<li>領域の指数関数的増加: 「ReLUネットワークが地図を分割できる最大領域数は、ネットワークの層数に応じて指数関数的に増加する」ことが示されています(0:24:28)。例えば、各層に2個のニューロンを持つ4層ネットワーク（入力層と出力層を除く）は、理論上64の領域を生成できます。一方、同じ64個のニューロンを2層ネットワークの第1層に配置した場合、最大2,081の領域しか生成できません。しかし、同じニューロン数を4層に再配置すると、「理論上の最大値は7000万以上の領域に達します。」(0:26:18) この「成長率の差は説得力があり、深層学習が効果的である理由としてしばしば挙げられます。」(0:26:48) ただし、これらは理論上の上限であり、「実際には、層を追加しても深層ネットワークによって作成される領域の指数関数的な増加は通常見られません。」(0:26:48)</li>
<li>勾配降下による複雑な学習: 深層モデルの学習は、特にバールレ＝ヘルトフのような複雑な境界線において、より多くのトレーニングステップを必要としますが、「勾配降下が私たちの町の詳細な構造を捉えるために、これらの追加の小さな多角形をどのように作成するかを理解するのは非常に興味深いです。」(0:28:26) 最終的に、「わずか4層で各層に32個のニューロンを持つモデルが、このレベルの複雑さを学習できる」ことは注目に値し(0:30:07)、最終的な決定境界は「町のすべての領域を印象的に捉えています。」(0:30:11)</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-ニューラルネットワーク研究の進化と教育への貢献">3. ニューラルネットワーク研究の進化と教育への貢献<a href="#3-ニューラルネットワーク研究の進化と教育への貢献" class="hash-link" aria-label="3. ニューラルネットワーク研究の進化と教育への貢献 への直接リンク" title="3. ニューラルネットワーク研究の進化と教育への貢献 への直接リンク">​</a></h3><ul>
<li>10年間の進歩: ソースの作成者は、10年前に最初のニューラルネットワーク関連の動画を公開して以来、この分野がどのように  進化してきたかを振り返っています。「コアとなるアプローチのほとんどは変わっていないものの、これらのコアアイデアは信じられないほど複雑な問題を解決するためにスケールアップされています。」(0:30:40) 特に、損失ランドスケープの高次元性、バックプロパゲーションのメカニズム、そして本動画で示された「深層モデルがどのように再帰的に入力空間を折りたたみ、スケールし、結合し、驚くほど少ないニューロン数で信じられないほど複雑なパターンを学習できるか」が強調されています(0:31:38)。</li>
<li>Welch Labsの目的: 作成者は、自身のプロジェクトであるWelch Labsを通じて、数学と科学の教育をより良くしたいという個人的な動機を共有しています(0:32:24)。彼は、幼少期の学校での学習経験が好ましくなかったこと、そして自身の努力を通じて再び数学と科学への愛を見出した経験に言及しています。Welch Labsを継続するためには、「実現可能なビジネスを構築する必要がある」と認識しており(0:32:46)、スポンサーシップやPatreonからの支援がその目標達成に不可欠であることを述べています(0:33:09)。</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="結論">結論<a href="#結論" class="hash-link" aria-label="結論 への直接リンク" title="結論 への直接リンク">​</a></h3><p>ユニバーサル近似定理は、理論的には2層ニューラルネットワークが任意の連続関数を近似できることを保証しますが、実践的には、特に複雑な問題において、その解決策を効率的に見つけることは困難です。</p><p>これは、勾配降下法が局所的な最適解に陥る可能性や、必要なニューロン数が指数関数的に膨大になる可能性によるものです。これに対し  、深層ニューラルネットワークは、ReLUのような活性化関数を通じて非線形な「折りたたみ」操作を多層にわたって連鎖させることで、入力空間をはるかに複雑な方法で分割し、より少ないニューロン数で極めて精度の高い決定境界を学習する能力を持ちます。</p><p>この「深さ」による能力の向上は、現在のディープラーニングの成功の重要な要因であり、理論的な領域の指数関数的増加という概念によって裏打ちされています。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="普遍的近似定理">普遍的近似定理<a href="#普遍的近似定理" class="hash-link" aria-label="普遍的近似定理 への直接リンク" title="普遍的近似定理 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>ディープラーニングが異常にうまく機能する理由という文脈において、提示されたソースは普遍的近似定理について以下の点を述べています。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="普遍的近似定理の定義とその保証">普遍的近似定理の定義とその保証<a href="#普遍的近似定理の定義とその  保証" class="hash-link" aria-label="普遍的近似定理の定義とその保証 への直接リンク" title="普遍的近似定理の定義とその保証 への直接リンク">​</a></h3><ul>
<li>普遍的近似定理は、‌<strong>‌ジョージ・シバンコ‌</strong>‌によって1989年に証明されました。</li>
<li>この定理は、ベルギーとオランダの複雑な国境線のような、ある複雑な関数（複雑な境界線）があった場合、‌<strong>‌2層ニューラルネットワーク‌</strong>‌が存在し、この境界線を望むだけ正確に近似できることを保証します。</li>
<li>第1層にニューロンを追加し続ければ、最終的に完全な境界線を表現できるアーキテクチャにたどり着くことが保証されています。</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="理論と実践のギャップ">理論と実践のギャップ<a href="#理論と実践のギャップ" class="hash-link" aria-label="理論と実践のギャップ への直接リンク" title="理論と実践のギャップ への直接リンク">​</a></h3><ul>
<li>定理は「存在」を保証しますが、‌<strong>‌「実践的にその解決策を見つけられる」とは限りません‌</strong>‌。</li>
<li>実際に、第1層に‌<strong>‌100,000個ものニューロンを持つモデル‌</strong>‌でも、都市の境界線を完全に一致させるように訓練することはできませんでした。この結果は、普遍的近似定理が実際に機能していないように感じさせます。</li>
<li>普遍的近似定理は、「ニューラルネットワークは何でも学習できる」と誤解されることがありますが、実際には「‌<strong>‌十分に広いニューラルネットワークは任意の連続関数を表現できる‌</strong>‌」と述べています。ここでの「連続性」は、境界線を見つけるために交差する最終的な表  面の連続性を指します。</li>
<li>さらに、この定理は‌<strong>‌特定のタスクを解決するために実際に必要なニューロンの数を教えてくれません‌</strong>‌。</li>
<li>現代のニューラルネットワークが学習に用いる‌<strong>‌バックプロパゲーションと勾配降下法は、最適な、あるいは良い解決策を見つけることを保証しません‌</strong>‌。勾配降下法は、ReLU活性化関数のゼロ化された部分を通る勾配がゼロになるため、特定の初期設定から回復できず、最適ではない線形決定境界にとどまってしまうことがあります。非常に広いネットワークの場合でも、勾配降下法では到達できない良い解決策が存在する可能性があります。</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ディープネットワークの利点と効率性">ディープネットワークの利点と効率性<a href="#ディープネットワークの利点と効率性" class="hash-link" aria-label="ディープネットワークの利点と効率性 への直接リンク" title="ディープネットワークの利点と効率性 への直接リンク">​</a></h3><ul>
<li>第1層に100,000個のニューロンを持つモデルと比較して、わずか130個のニューロンを持つ‌<strong>‌5層ネットワークは、より精密な境界線を学習し、マップをより効果的に分割できました‌</strong>‌。</li>
<li>ニューロンを多層に再配置することが、モデルをはるかに強力にする理由についての問いが提起されています。</li>
<li>‌<strong>‌浅いネットワークで必要なニューロンの数は、深いネットワークで必要なニューロンの数よりも指数関数的に大きくなる‌</strong>‌ことが、特定の種類の関数で示されています。これは、100,000個のニューロンでも十分ではない可能性を示 唆しています。</li>
<li>ニューロンを追加の層に重ねて「‌<strong>‌深くする‌</strong>‌」ことで、‌<strong>‌驚くべき効率向上‌</strong>‌を達成できます。</li>
<li>多層ネットワークは、折りたたみ、スケーリング、結合の操作を繰り返すことで、これらの操作を複合させ、‌<strong>‌より複雑なパターンを生成‌</strong>‌することを可能にします。</li>
<li>ReLUネットワークがマップを分割できる‌<strong>‌最大領域の数は、ネットワークの層数に対して指数関数的に増加する‌</strong>‌ことが示されています。<!-- -->
<ul>
<li>2層ネットワークでは、最大領域数はニューロン数の多項式関数として増加します。</li>
<li>対照的に、深いネットワークでは、層数に応じて指数関数的に増加します。</li>
<li>例えば、64個のニューロンを1つの層に配置した2層ネットワークでは最大2,081個の領域が可能ですが、同じニューロンを4層に再配置すると、理論上7,000万以上の領域が可能になります。</li>
</ul>
</li>
<li>この成長率の差は非常に説得力があり、‌<strong>‌ディープラーニングの有効性の理由‌</strong>‌としてしばしば指摘されます。</li>
<li>ただし、これらの数値は理論上の上限であり、実際には層を追加しても、深いネットワークによって作成される領域の指数関数的な成長は通常見られません。</li>
<li>それでも、わずか4層で各層に32個のニューロンを持つモデルが、町の境界線のあらゆる領域を捉えるほどの‌<strong>‌驚くべき複雑さを学習できる‌</strong>‌ことは注目に値します。</li>
<li>結論として、深いモデルが入力空間を再帰的に折りたたみ、スケーリングし、結合することで、‌<strong>‌非常に少ないニューロンで信 じられないほど複雑なパターンを学習できる‌</strong>‌ことが示されています。</li>
</ul></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ニューラルネットワークの幾何学的解釈">ニューラルネットワークの幾何学的解釈<a href="#ニューラルネットワークの幾何学的解釈" class="hash-link" aria-label="ニューラルネットワークの幾何学的解釈 への直接リンク" title="ニューラルネットワークの幾何学的解釈 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>ディープラーニングが異常にうまく機能する理由という大きな文脈において、提示されたソースはニューラルネットワークの幾何学的解釈について詳しく説明しています。特に、ニューロンが入力空間をどのように変換し、それが最終的な決定境界にどのように影響するかという点に焦点を当てています。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-浅い2層ニューラルネットワークの幾何学的解釈">1. 浅い（2層）ニューラルネットワークの幾何学的解釈<a href="#1-浅い2層ニューラルネットワークの幾何学的解釈" class="hash-link" aria-label="1. 浅い（2層）ニューラルネットワークの幾何学的解釈 への直接リンク" title="1. 浅い（2層）ニューラルネットワークの幾何学的解釈 への直接リンク">​</a></h3><ul>
<li>
<p>‌<strong>‌基本的な構成要素としての「平面」と「折り畳み」‌</strong>‌:</p>
<ul>
<li>現代のほとんどのニューラルネットワークは、‌<strong>‌整流線形活性化関数 (ReLU)‌</strong>‌ の一種を使用しています。</li>
<li>ネットワークの第1層の各ニューロンは、学習された重みによって制御される単一の折り目線に沿って、マップのコピーを‌<strong>‌折り畳みます‌</strong>‌。</li>
<li>数学的には、各ニューロンは入力座標を受け取り、それぞれの座標を学習された重みで乗算し、バイアスを加えることで、‌<strong>‌平面‌</strong>‌を生成します。これらの重みは平面の傾きを、バイアスは平面の上下へのシフトを制御します。</li>
<li>ReLU活性化関数を適用すると、高さが0より小さい平面の領域は0の高さに‌<strong>‌折り畳まれ‌</strong>‌、これにより平面ではなく‌<strong>‌曲がった平面‌</strong>‌が出力されます。</li>
</ul>
</li>
<li>
<p>‌<strong>‌第2層での結合と決定境界の形成‌</strong>‌:</p>
<ul>
<li>第2層のニューロンは、これらの曲がった平面を受け取り、その高さを別の学習された重みで乗算し、幾何学的に曲がった部分をさらに上下に曲げたり、重み値が負の場合は折り畳まれた領域を反転させたりします。</li>
<li>これらの曲がった平面は、ニューロンによって合計され、‌<strong>‌表面‌</strong>‌を形成します。</li>
<li>第1層からの折り目線はマップをいくつかの‌<strong>‌領域‌</strong>‌に分割し、それぞれの領域が第2層の  表面で異なる平面となります。</li>
<li>これらの表面の高さは、モデルが特定の国（例：ベルギーやオランダ）にあるという確信度に対応します。</li>
<li>2つの表面の交差は、モデルが両方の国に等しく確信を持っている場所を示し、これがモデルの学習された‌<strong>‌決定境界‌</strong>‌となり、基本的な国境を形成します。</li>
</ul>
</li>
<li>
<p>‌<strong>‌ニューロン数の増加による影響‌</strong>‌:</p>
<ul>
<li>普遍的近似定理は、第1層にニューロンを追加し続けると、最終的に完全な国境を表現できるアーキテクチャに到達することを保証します。</li>
<li>より多くのニューロン（例：8個、16個、…、100,000個）を追加すると、より多くの折り目を生成でき、マップをより多くの領域に分割し、より複雑な表面を形成し、より詳細な決定境界を生成します。</li>
<li>しかし、100,000個のニューロンを持つモデルでさえ、実際には国境の一部を学習しきれていない例が示されており、普遍的近似定理が実践的に機能していないように感じられると述べられています。</li>
</ul>
</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-深い多層ニューラルネットワークの幾何学的解釈">2. 深い（多層）ニューラルネットワークの幾何学的解釈<a href="#2-深い多層ニューラルネットワークの幾何学的解釈" class="hash-link" aria-label="2. 深い（多層）ニューラルネットワークの幾何学的解釈 への直接リンク" title="2. 深い（多層）ニューラルネットワークの幾何学的解釈 への直接リンク">​</a></h3><ul>
<li>
<p>‌<strong>‌「深くする」ことによる効率性と複雑性‌</strong>‌:</p>
<ul>
<li>ソースは、‌<strong>‌ニューロンを追加の層に重ねて「深くする」‌</strong>‌ことによって、驚くべき効率向上を達成できることを強調しています。</li>
<li>例えば、合計130個のニューロンを持つ5層ネットワークが、100,000個のニューロンを持つ浅いモデルよりも‌<strong>‌より正確な境界線を学習し、マップをより効果的に分割できた‌</strong>‌ことが示されています。</li>
<li>これは、浅いネットワークで必要なニューロンの数が、深いネットワークで必要なニューロンの数よりも‌<strong>‌指数関数的に大きくなる‌</strong>‌ことが、特定の種類の関数で示されているためです。</li>
</ul>
</li>
<li>
<p>‌<strong>‌層の積み重ねによる幾何学的変換の複合‌</strong>‌:</p>
<ul>
<li>浅いモデルと深いモデルの両方のニューロンは、同じ‌<strong>‌折り畳み、スケーリング、結合‌</strong>‌の操作を行います。</li>
<li>しかし、これらの操作が多層で複合されると、はるかに強力になります。</li>
<li>もしReLU活性化関数を使用しない場合、層を重ねても代数的に単一の層に‌<strong>‌崩壊‌</strong>‌し、実際には単一の傾いた平面しか適合できないことが示されています。これは、複雑なパターンを学習するためにReLUのような非線形活性化関数がいかに重要であるかを強調しています。</li>
<li>深いネットワークでは、第1層が入力平面を折り畳んだ後、第2層のReLU活性化関数は、もはや単純な平面ではない表面に適用されます。これにより、複数の新しい折り目線が作成され、これらの折り目は異なる角度で、前の層の平面の接合部で曲がるという、‌<strong>‌はるかに複雑な幾何学‌</strong>‌が生成されます。</li>
<li>これにより、単一のニューロンがかなり複雑な幾何学を持つ‌<strong>‌複数の異なる折り 目‌</strong>‌を作成できるようになります。</li>
<li>この再帰的な折り畳み、スケーリング、結合の操作を繰り返すことで、これらの操作は‌<strong>‌複合‌</strong>‌し、ニューロンがより複雑なパターンを生成できるようになります。</li>
</ul>
</li>
<li>
<p>‌<strong>‌領域数の指数関数的増加‌</strong>‌:</p>
<ul>
<li>ReLUネットワークがマップを分割できる‌<strong>‌最大領域の数は、ネットワークの層数に対して指数関数的に増加する‌</strong>‌ことが示されています。<!-- -->
<ul>
<li>浅い（2層）ネットワークでは、最大領域数はニューロン数の‌<strong>‌多項式関数‌</strong>‌として増加します。</li>
<li>対照的に、深いネットワークでは、層数に応じて‌<strong>‌指数関数的に増加‌</strong>‌します。</li>
</ul>
</li>
<li>例えば、64個のニューロンを1つの層に配置した2層ネットワークでは最大2,081個の領域が可能ですが、同じニューロンを4層に再配置すると、理論上7,000万以上の領域が可能になります。</li>
<li>この成長率の差は非常に説得力があり、‌<strong>‌ディープラーニングの有効性の理由‌</strong>‌としてしばしば指摘されます。</li>
<li>ただし、これらの数値は理論上の上限であり、実際には層を追加しても、深いネットワークによって作成される領域の指数関数的な成長は通常見られないと注意されています。</li>
<li>それでも、わずか4層で各層に32個のニューロンを持つモデルが、町の境界線のあらゆる領域を捉えるほどの‌<strong>‌驚くべき複雑さを学習できる‌</strong>‌ことは注目に値します。</li>
</ul>
</li>
<li>
<p>‌<strong>‌勾配降下法の限界‌</strong>‌:</p>
<ul>
<li>普遍的近似定理は解決策の‌<strong>‌存在‌</strong>‌を保証しますが、‌<strong>‌実践的にその解決策を見つけられるとは限りません‌</strong>‌。</li>
<li>現代のニューラルネットワークが学習に用いるバックプロパゲーションと勾配降下法は、最適な、あるいは良い解決策を見つけることを保証しません。</li>
<li>勾配降下法は、ReLU活性化関数のゼロ化された部分を通る勾配がゼロになるため、特定の初期設定から回復できず、最適ではない線形決定境界にとどまってしまうことがあります。非常に広いネットワークの場合でも、勾配降下法では到達できない良い解決策が存在する可能性があります。</li>
</ul>
</li>
</ul><p>結論として、深いモデルは入力空間を‌<strong>‌再帰的に折り畳み、スケーリングし、結合する‌</strong>‌ことによって、‌<strong>‌非常に少ないニューロンで信じられないほど複雑なパターンを学習できる‌</strong>‌ことが、幾何学的な観点から明確に示されています。これにより、ディープラーニングは、従来の浅いモデルでは効率的に処理できなかったような複雑な問題を解決する上で、異常なほどの能力を発揮するのです。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="浅いネットワークと深いネットワークの対比">浅いネットワークと深いネットワークの対比<a href="#浅いネットワークと深いネットワークの対比" class="hash-link" aria-label="浅いネットワークと深いネットワークの対比 への直接リンク" title="浅いネットワークと深いネットワークの対比 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>ディープラーニングが異常にうまく機能する理由というより大きな文脈において、提示されたソースは‌<strong>‌ワイドネットワーク（浅いネットワーク）‌</strong>‌と‌<strong>‌ディープネットワーク（深いネットワーク）‌</strong>‌の間の重要な違いと、それがニューラルネットワークの幾何学的解釈にどのように関連するかを詳細に議論しています。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ワイドネットワーク浅い2層ニューラルネットワークの幾何学的解釈と限界">ワイドネットワーク（浅い2層ニューラルネットワーク）の幾何学的解釈と限界<a href="#ワイドネットワーク浅い2層ニューラルネットワークの幾何学的解釈と限界" class="hash-link" aria-label="ワイドネットワーク（浅い2層ニューラルネットワーク）の幾何学的解釈と限界 への直接リンク" title="ワイドネットワーク（浅い2層ニューラルネットワーク）の幾何学的解釈と限界 への直接リンク">​</a></h3><ul>
<li>
<p>‌<strong>‌構成と決定境界‌</strong>‌:</p>
<ul>
<li>ユニバーサル近似定理は、‌<strong>‌2層ニューラルネットワーク‌</strong>‌が、十分な数のニューロンを持つ場合、ベルギーとオランダの複雑な国境のような任意の連続関数を望むだけ正確に近似できることを保証します。</li>
<li>幾何学的には、ネットワークの‌<strong>‌第1層の各ニューロンは、学習された重みによって制御される単一の折り目線に沿ってマップを「折り畳み」ます‌</strong>‌。ReLU活性化関数が適用されることで、高さが0より小さい領域は0に「折り畳まれ」て、「曲がった平面」が出力されます。</li>
<li>第2層のニューロンは、これらの曲がった平面を受け取り、それらの高さを別の学習された重みで乗算し、結合することで「表面」を形成します。</li>
<li>これらの表面の交差が、モデルの学習された「決定境界」となり、基本的な国境を形成します。</li>
<li>第1層の折り目線はマップを複数の領域に分割し、それぞれの領域が第2層の表面で異なる平面となります。</li>
</ul>
</li>
<li>
<p>‌<strong>‌ニューロン数の増加と課題‌</strong>‌:</p>
<ul>
<li>ソースは、第1層にニューロンを追加し続けることで、より多くの折り目を生成し、マップをより多くの領域に分割し、より複雑な表面と詳細な決定境界を生成できることを示しています。</li>
<li>しかし、実際には、‌<strong>‌100,000個ものニューロンを持つモデルでさえ、ベルギーとオランダの国境の一部を完全に学習しきれていない‌</strong>‌例が示されています。これは、ユニバーサル近似定理が「うまく機能していないように感じる」状況を示唆しています。</li>
<li>ユニバーサル近似定理は解決策の‌<strong>‌存在‌</strong>‌を保証するものの、‌<strong>‌実践的にその解決策を見つけられることを保証するものではない‌</strong>‌、という点が強調されています。また、特定の解決策を見つけるために実際にどれだけ  のニューロンが必要かについては教えてくれません。</li>
<li>勾配降下法は、最適な、あるいは良い解決策を見つけることを保証せず、特定の初期設定から回復できない場合があり、最適ではない線形決定境界にとどまってしまうことがあります。非常に広いネットワークの場合でも、勾配降下法では到達できない良い解決策が存在する可能性があります。</li>
</ul>
</li>
<li>
<p>‌<strong>‌領域数の増加‌</strong>‌:</p>
<ul>
<li>2層ネットワークでは、モデルがマップを分割できる‌<strong>‌最大領域の数は、ニューロン数の多項式関数として増加します‌</strong>‌。例えば、64個のニューロンを持つ2層ネットワークでは、最大2,081個の領域を作成できます。</li>
</ul>
</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ディープネットワーク多層ニューラルネットワークの幾何学的解釈と優位性">ディープネットワーク（多層ニューラルネットワーク）の幾何学的解釈と優位性<a href="#ディープネットワーク多層ニューラルネットワークの幾何学的解釈と優位性" class="hash-link" aria-label="ディープネットワーク（多層ニューラルネットワーク）の幾何学的解釈と優位性 への直接リンク" title="ディープネットワーク（多層ニューラルネットワーク）の幾何学的解釈と優位性 への直接リンク">​</a></h3><ul>
<li>
<p>‌<strong>‌驚異的な効率向上‌</strong>‌:</p>
<ul>
<li>ソースは、ニューロンを追加の層に‌<strong>‌「深くする」‌</strong>‌ことによって、驚くべき効率向上を達成できることを強調しています。</li>
<li>例えば、合計130個のニューロンを持つ5層ネットワークが、‌<strong>‌100,000個のニューロンを持つ浅いモデルよりも、より正確な境界 線を学習し、マップをより効果的に分割できた‌</strong>‌ことが示されています。</li>
<li>これは、特定の種類の関数では、浅いネットワークで必要なニューロンの数が、深いネットワークで必要なニューロンの数よりも‌<strong>‌指数関数的に多くなる‌</strong>‌ことが示されているためです。</li>
</ul>
</li>
<li>
<p>‌<strong>‌幾何学的変換の複合‌</strong>‌:</p>
<ul>
<li>深いモデルのニューロンは、浅いモデルと同じ「折り畳み、スケーリング、結合」の操作を行いますが、これらの操作が‌<strong>‌多層で複合されると、はるかに強力になります‌</strong>‌。</li>
<li>ReLUのような非線形活性化関数がなければ、層を重ねても単一の層に「崩壊」してしまい、単一の傾いた平面しか適合できません。</li>
<li>深いネットワークでは、第1層が入力平面を折り畳んだ後、第2層のReLU活性化関数は、もはや単純な平面ではない表面に適用されます。これにより、複数の新しい折り目線が作成され、これらの折り目は異なる角度で、前の層の平面の接合部で曲がるという、‌<strong>‌はるかに複雑な幾何学‌</strong>‌が生成されます。</li>
<li>これにより、単一のニューロンがかなり複雑な幾何学を持つ‌<strong>‌複数の異なる折り目‌</strong>‌を作成できるようになります。この再帰的な折り畳み、スケーリング、結合の操作を繰り返すことで、これらの操作が‌<strong>‌複合‌</strong>‌し、ニューロンがより複雑なパターンを生成できるようになります。</li>
</ul>
</li>
<li>
<p>‌<strong>‌領域数の指数関数的増加‌</strong>‌:</p>
<ul>
<li>ReLUネットワークがマップを分割できる‌<strong>‌最大領域の数は、ネットワークの層数に対して指数関数的に増加する‌</strong>‌ことが示されています。</li>
<li>例えば、64個のニューロンを4層に再配置すると、理論上7,000万以上の領域が可能になります。</li>
<li>この成長率の差は非常に説得力があり、‌<strong>‌ディープラーニングの有効性の理由‌</strong>‌としてしばしば指摘されます。</li>
<li>ただし、これらの数値は理論上の上限であり、実際には層を追加しても、深いネットワークによって作成される領域の指数関数的な成長は通常見られないと注意されています。それでも、わずか4層で各層に32個のニューロンを持つモデルが、町の境界線のあらゆる領域を捉えるほどの‌<strong>‌驚くべき複雑さを学習できる‌</strong>‌ことは注目に値します。</li>
</ul>
</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ワイドネットワークとディープネットワークの比較">ワイドネットワークとディープネットワークの比較<a href="#ワイドネットワークとディープネットワークの比較" class="hash-link" aria-label="ワイドネットワークとディープネットワークの比較 への直接リンク" title="ワイドネットワークとディープネットワークの比較 への直接リンク">​</a></h3><table><thead><tr><th style="text-align:left">特徴</th><th style="text-align:left">ワイドネットワーク（浅い2層）</th><th style="text-align:left">ディープネットワーク（多層）</th></tr></thead><tbody><tr><td style="text-align:left">‌<strong>‌幾何学的変換‌</strong>‌</td><td style="text-align:left">各ニューロンが入力空間に単一の折り目（線形な折り目線）を作成する。</td><td style="text-align:left">層を重ねることで、幾何学的変換が複合し、複雑な折り目や非線形な分割を生成する。</td></tr><tr><td style="text-align:left">‌<strong>‌効率（ニューロン数）‌</strong>‌</td><td style="text-align:left">複雑なパターンを学習するために指数関数的に多くのニューロンが必要になる可能性が高い。</td><td style="text-align:left">‌<strong>‌少ないニューロンで信じられないほど複雑なパターンを学習できる‌</strong>‌。</td></tr><tr><td style="text-align:left">‌<strong>‌マップの分割能力（領域数）‌</strong>‌</td><td style="text-align:left">ニューロン数の‌<strong>‌多項式関数‌</strong>‌として最大領域数が増加する。</td><td style="text-align:left">層数に対して‌<strong>‌指数関数的に‌</strong>‌最大領域数が増加する。</td></tr><tr><td style="text-align:left">‌<strong>‌実践的な学習能力‌</strong>‌</td><td style="text-align:left">ユニバーサル近似定理は存在を保証するが、勾配降下法が最適な解決策を見つけられない場合がある。</td><td style="text-align:left">少ないニューロンで非常に複雑な境界線を学習し、マップを効果的に分割できる。</td></tr><tr><td style="text-align:left">‌<strong>‌複雑性の生成‌</strong>‌</td><td style="text-align:left">「線を重ねただけ」のような印象の幾何学パターン。</td><td style="text-align:left">全く異なる複雑な「タイリング」（分割）を生成できる。</td></tr></tbody></table><p>結論として、ディープラーニングが異常にうまく機能する理由は、深いモデルが‌<strong>‌入力空間を再帰的に折り畳み、スケーリングし、結合する‌</strong>‌ことで、‌<strong>‌非常に少ないニューロンで信じられないほど複雑なパターンを学習できる‌</strong>‌という幾何学的な能力にあります。これにより、従来の浅いモデルでは効率的に処理できなかったような複雑な問題を、はるかに効率的に解決できる  ようになるのです。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="学習プロセスと課題">学習プロセスと課題<a href="#学習プロセスと課題" class="hash-link" aria-label="学習プロセスと課題 への直接リンク" title="学習プロセスと課題 への直接リンク">​</a></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div><div class="admonitionContent_BuS1"><p>ディープラーニングが異常にうまく機能する理由というより大きな文脈において、提示されたソースは、ニューラルネットワークの‌<strong>‌学習プロセス‌</strong>‌とそれに伴う‌<strong>‌課題‌</strong>‌について詳細に議論しています。特に、普遍近似定理が保証する「存在」と、実際の学習アルゴリズムである勾配降下法がその「解決策を見つける能力」との間のギャップが強調されています。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="学習プロセス">学習プロセス<a href="#学習プロセス" class="hash-link" aria-label="学習プロセス への直接リンク" title="学習プロセス への直接リンク">​</a></h3><p>ニューラルネットワークの学習プロセスは、主に‌<strong>‌バックプロパゲーション と勾配降下法‌</strong>‌に基づいて行われます。</p><ul>
<li>‌<strong>‌初期化と予測‌</strong>‌:<!-- -->
<ul>
<li>学習前、ネットワークは‌<strong>‌ランダムに初期化‌</strong>‌されます。これにより、第1層の折り目線はマップ上のランダムな位置に配置され、トレーニング前の決定境界も初期状態では適切ではありません。</li>
<li>モデルは入力データを受け取り、その現在のパラメーターに基づいて予測を行います。例えば、ベルギーの地点が与えられた場合、初期のランダムなモデルではその地点を誤ってオランダと分類する可能性があります。</li>
</ul>
</li>
<li>‌<strong>‌誤差の測定‌</strong>‌:<!-- -->
<ul>
<li>モデルの予測と実際の正解との間の誤差は、‌<strong>‌クロスエントロピー損失‌</strong>‌などの損失関数を用いて測定されます。この損失値は、モデルがどれだけ間違っているかを示します。</li>
</ul>
</li>
<li>‌<strong>‌勾配の計算と更新‌</strong>‌:<!-- -->
<ul>
<li>測定された損失は‌<strong>‌バックプロパゲーションアルゴリズム‌</strong>‌を通じて実行され、各モデルパラメーター（重みとバイアス）に対する‌<strong>‌勾配‌</strong>‌が計算されます。</li>
<li>勾配は、損失を減少させるために各パラメーターをどのように調整すべきかを示します。例えば、ある重みに対する勾配が大きく負である場合、損失を減らすためにはその重みを増やすべきだと示唆されます。</li>
<li>これらの勾配に従って、モデルのパラメーターは‌<strong>‌小さな反復的な更新‌</strong>‌を受けます。これにより、折り目線の位置や、これらの曲がった平面がどのように結合されるかが調整されます。</li>
<li>この勾配降下プロセ  スをステップバイステップで繰り返すことで、モデルは徐々に損失を減らし、より正確な決定境界を学習します。</li>
</ul>
</li>
<li>‌<strong>‌学習の停止‌</strong>‌:<!-- -->
<ul>
<li>通常、学習プロセスは、モデルのパフォーマンスが向上しなくなった時点で停止されます。</li>
</ul>
</li>
</ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="学習の課題と限界">学習の課題と限界<a href="#学習の課題と限界" class="hash-link" aria-label="学習の課題と限界 への直接リンク" title="学習の課題と限界 への直接リンク">​</a></h3><p>ソースは、特にワイド（浅い）ネットワークにおいて、学習プロセスが直面するいくつかの重要な課題を指摘しています。</p><ul>
<li>‌<strong>‌普遍近似定理の「落とし穴」‌</strong>‌:<!-- -->
<ul>
<li>‌<strong>‌普遍近似定理‌</strong>‌は、十分な数のニューロンを持つ2層ニューラルネットワークが、任意の連続関数を望むだけ正確に近似できることを保証します。</li>
<li>しかし、この定理は‌<strong>‌解決策が「存在する」ことを保証するものの、実践的にその解決策を「見つけられる」ことを保証しません‌</strong>‌。</li>
<li>また、定理は‌<strong>‌特定のタスクを解決するために実際にどれだけのニューロンが必要か‌</strong>‌を教えてくれません。</li>
</ul>
</li>
<li>‌<strong>‌勾配降下法の限界‌</strong>‌:<!-- -->
<ul>
<li>勾配降下法は、‌<strong>‌最適な、あるいは良い解決策を見つけることを保証しません‌</strong>‌。</li>
<li>モデルの初期化が悪い場合、勾配降下法は‌<strong>‌望ましくない構成から回復できない‌</strong>‌ことがあります。例えば、決定境界が平面から押し出されてしまい、ReLUのゼロ化された部分に入ってしまうと、その部分の勾配もゼロになるため、モデルは実質的に単一の平面でしか機能せず、最適ではない線形決定境界にとどまってしまいます。これは、‌<strong>‌「デッドニューロン」‌</strong>‌として知られる現象の一種で、特定のニューロンの出力が常に0になることで、そのニューロンが学習に貢献できなくなる状態を指します。</li>
<li>非常にワイドな10万ニューロンのネットワークの場合でも、良い解決策が存在するにもかかわらず、勾配降下法では到達できない可能性があります。</li>
<li>大規模モデルでは勾配降下法が局所最適解に陥る可能性は低いとされていますが、それでも解決策を見つけることの難しさは残ります。</li>
</ul>
</li>
<li>‌<strong>‌ニューロン数の多さの非効率性‌</strong>‌:<!-- -->
<ul>
<li>ユニバーサル近似定理が示すようにニューロン数を増やし続けることで、確かに真の境界線に近づくことはできますが、‌<strong>‌10万個ものニューロンを持つモデルでさえ、ベルギーとオランダの国境の一部を完全に学習しきれていない‌</strong>‌例が示されています。</li>
<li>特定の種類の関数では、浅いネットワークで必要なニューロンの数が、深いネットワークで必要なニューロンの数よりも‌<strong>‌指数関数的に多くなる‌</strong>‌ことが示されています。これは、ただニューロンを増やして「ワイドにする」だけでは効率が悪いことを意味します。</li>
<li>理論上、浅いネットワークが生成できる最大領域の数はニューロン数の多項式関数として増加するのに対し、深いネットワークは層数に対して‌<strong>‌指数関数的に‌</strong>‌増加します。この効率の差が、ディープラーニ  ングが「異常にうまく機能する」理由の重要な側面です。</li>
</ul>
</li>
</ul><p>まとめると、ディープラーニングの学習プロセスは、バックプロパゲーションと勾配降下法による反復的なパラメーター調整によって行われますが、その成功は普遍近似定理が保証する「存在」と、勾配降下法が実際に「見つける」能力との間の複雑な相互作用に依存します。‌<strong>‌ディープネットワークは、はるかに少ないニューロンで驚くほど複雑なパターンを学習できる‌</strong>‌ことが示されており、これは、多層構造が幾何学的変換を複合させ、学習プロセスがより効率的かつ効果的に機能するような入力空間の分割を可能にするためであると考えられます。</p></div></div>
<h2></h2>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>AI</div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="情報源">情報源<a href="#情報源" class="hash-link" aria-label="情報源 への直接リンク" title="情報源 への直接リンク">​</a></h2>
<p>Why Deep Learning Works Unreasonably Well</p>
<p>動画(34:08)</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/qx7hirqgfuU?si=2LSG_irXddLkfRPa" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin"></iframe>
<p><a href="https://www.youtube.com/watch?v=qx7hirqgfuU" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=qx7hirqgfuU</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="動画概要欄">動画概要欄<a href="#動画概要欄" class="hash-link" aria-label="動画概要欄 への直接リンク" title="動画概要欄 への直接リンク">​</a></h3>
<p>63,100 views  Aug 10, 2025</p>
<p>Take your personal data back with Incogni! Use code WELCHLABS and get 60% off an annual plan: <a href="http://incogni.com/welchlabs" target="_blank" rel="noopener noreferrer">http://incogni.com/welchlabs</a></p>
<p>New Patreon Rewards 33:31- own a piece of Welch Labs history!</p>
<details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>展開</summary><div><div class="collapsibleContent_i85q"><p>In 1989, George Sibanko proved what&#x27;s now known as the Universal Approximation Theorem. If we take some complex function, for example this really complicated border in the town of Barley-Hertog, these parts of the map are in Belgium and these parts are in the Netherlands, the Universal Approximation Theorem guarantees that there exists a two-layer neural network that can fit this border as precisely as we want.
(0:00:24)</p><p>A nice way to get a feel for this result is to see what a two-layer network like this does geometrically.
Most modern neural networks use some version of rectified linear activation functions.
Visually this means that each neuron in the first layer of our network folds up a copy of our map along a single fold line, where the location of the fold line is controlled by the neuron&#x27;s learned weights.
(0:00:46)</p><p>From here, our first neuron in our second layer takes in these bent planes, and multiplies their heights by another learned weight value, which geometrically further bends up or down the folded parts of our planes, and flips over our folded region when that neuron&#x27;s weight value is negative.
These three bent planes are then added together by our neuron, resulting in a surface like this. Our three fold lines from our first layer now divide up our map into these five regions, that each become different planes in our second layer&#x27;s surface.
(0:01:17)</p><p>This surface shows the output of our first neuron in our second layer.
The second neuron in our second layer flips, scales, and combines our first planes using different learned parameters, resulting in this surface, that again uses the same five regions of our map, but at different heights.
The height of the surface formed by our first neuron corresponds to the model&#x27;s confidence in a certain part of the map being in the Netherlands. And the height of the second neuron&#x27;s surface corresponds to the model&#x27;s confidence in Belgium. Coloring our Netherlands surface blue, and our Belgium surface yellow, and bringing these surfaces together onto the same axis, the intersection of our surfaces shows us where our model is equally confident in both countries.
(0:01:59)</p><p>This is the model&#x27;s learned decision boundary, which gives us a basic border, separating the core Belgium region from the surrounding Netherlands region.
Now the universal approximation theorem tells us that if we just keep adding neurons to our first layer, eventually we&#x27;ll land on an architecture capable of representing our full border.
Training a network with 8 neurons in its first layer, we get this set of 8 folds, leading to this surface for our first output neuron, and this surface for our second output neuron.
(0:02:29)</p><p>Bringing these new surfaces onto the same axis, we see these new more complex intersection lines, leading to this more detailed final border, that begins to break our map into separate regions.
Here&#x27;s the surfaces and border for a larger model with 16 neurons.
Here&#x27;s a 32 neuron model, here&#x27;s 64, and here&#x27;s 128. It starts to become difficult to see how our surfaces are intersecting exactly with this many fold lines.
(0:02:57)</p><p>Let&#x27;s flatten out our surfaces, to make it easier to see how the model uses all its different fold lines to fit our border.
(0:03:04)</p><hr><p>Doubling our neuron count again to 256. Here&#x27;s how our neurons divide up our map, and here&#x27;s the final decision boundary.
Here&#x27;s 512 neurons, and here&#x27;s 1024. We&#x27;re getting closer to our true border, but we&#x27;re still missing a number of parts of the town, and we&#x27;ve reached a point where I can&#x27;t actually render any more polygons, but we can still render our decision boundary.
(0:03:26)</p><p>Here&#x27;s the border we get with a 10,000 neuron model.
And finally here&#x27;s a model with 100,000 neurons.
We&#x27;re getting even closer at this point, but even with 100,000 neurons, there&#x27;s a couple parts of the border that our model hasn&#x27;t learned.
It feels like the universal approximation theorem isn&#x27;t really working.
What are we missing here?
But before we get into the details of what&#x27;s going wrong, let me show you one more thing.
(0:03:54)</p><p>Let&#x27;s take just 128 neurons, but instead of arranging them in a single wide layer, let&#x27;s arrange them in 4 separate layers of 32 each, like this, where the output of each layer is passed into the next.
After training this model, these are the resulting learned regions and decision boundary.
Our 5-layer network, with just 130 total neurons, is able to learn a more precise border than our 100,000 neuron model, and it&#x27;s able to divide up our map more effectively.
(0:04:24)</p><p>How is it that rearranging our neurons into multiple layers makes our model so much more powerful?
The neurons in both our deeper and shallow models do the same folding, scaling, and combining operations. Why are these operations so much more effective when composed in multiple layers?
And how does the geometry of our map change as it moves through these stacked operations?
This video is part of a series sponsored by Incogni. These videos have really pushed my animation abilities, requiring a bunch of deeply focused hours, which Incogni has really helped me with by significantly reducing the number of spam texts and calls that I receive.
(0:05:05)</p><p>Incogni also helps protect my privacy.
In the United States we have these people search sites, where for a small fee anyone can look up information about you, like your address, your email, phone number, education, employment history, social media accounts, and so on.
This gives you an idea of all the information about you that data brokers are able to gather and sell.
Last year I signed up for one of these people search sites, to see what information I could find on myself.
(0:05:30)</p><p>After being an Incogni customer for a few months, I impressively wasn&#x27;t able to find any information on myself, but I was able to find a ton of information on my wife.
Since then I&#x27;ve upgraded to Incogni&#x27;s friends and family plan and added my wife to the plan.
I checked the same people search site again this week, and was happy to see that all of her information had been removed.
(0:05:51)</p><p>Incogni has just released a new feature, that makes their service even more effective, called custom data removals.
(0:05:58)</p><hr><p>If you type your name and address into Google, you may be surprised to find where exactly your personal information pops up.
With custom removals, you can submit specific URLs directly to the Incogni team, who will work to remove your information from eligible sites.
You can get a great deal on Incogni, 60% off an annual plan, by visiting incogni.com forward slash welchlabs, and using code welchlabs at checkout.
(0:06:21)</p><p>It&#x27;s been a while since I&#x27;ve made a multi-part series like this.
Huge thanks to Incogni for helping make this series possible, and helping me get more quality focus time as I work on it.
Last time, in part 2 of this series, we dug into the mathematics of how modern models are trained using backpropagation and gradient descent.
We saw how given the inputs of latitude and longitude, a single layer model can effectively learn to position planes over different European cities, learning to separate Paris, Berlin, Madrid, and Barcelona. The key piece of functionality here is that our model learns to position the Madrid plane above all the other planes above Madrid, the Barcelona plane above all the other planes above Barcelona, and so on.
(0:07:04)</p><p>And the height of our planes corresponds to our network&#x27;s final confidence in a specific city. We left off considering the most complex geographic border in the world, between Belgium and the Netherlands, in the municipality of Barley-Hertog. Given a single plane for each country, there&#x27;s no way to position our planes, so our Belgium plane is on top of our Netherlands plane above only the Belgium portions of our map.
(0:07:29)</p><p>Another way to think about this is that our two tilted planes intersect at a line on our map, where everything on one side of the line will be classified as part of Belgium, and everything on the other side will be classified as part of the Netherlands. And there&#x27;s no way this linear decision boundary can correctly divide up our city.
Our networks from last time looked like this, with a single layer of neurons between our inputs and softmax function.
(0:07:53)</p><p>As we saw last time, the softmax function bends our planes to output nice final probability values. But importantly, it doesn&#x27;t change the location of the decision boundaries at the intersections of our planes.
For this reason, we won&#x27;t concern ourselves too much with softmax in this video.
The networks we saw at the beginning of this video add one more layer of neurons, and our models are able to accomplish significantly more.
(0:08:17)</p><p>Just like the neurons in our simple single layer model, each of the neurons in the first layer of our two layer network contains a simple linear model that geometrically looks like a plane.
Mathematically, the first neuron in our first layer takes in the coordinates of our point, multiplies each coordinate by a learned number called a weight, which we&#x27;re writing here using lowercase m&#x27;s, and adds these results together.
(0:08:41)</p><p>The weight values control the steepness of our plane in each direction.
(0:08:44)</p><hr><p>Finally, we add one more learnable parameter called a bias.
This shifts our whole plane up and down.
So if we pass in this Belgian point on our map, with coordinates of x1 equals 0.6 and x2 equals 0.4, we multiply our x1 value by our first weight, and our x2 value by our second weight, and add these results together.
And finally, we add our bias value to compute our final result of minus 0.14. This computed value corresponds to the height of our first neuron&#x27;s plane at these input coordinates. Now, if we just pass the height of our plane, minus 0.14 in this example, into our second layer of neurons, our multiple layers of neurons will actually just collapse back down into what is effectively a single layer of neurons.
(0:09:31)</p><p>We can show this collapsing algebraically.
There&#x27;s just a bunch of terms to deal with.
These first two equations correspond to the first two neurons in our first layer.
Note that we&#x27;re using these superscripts to keep track of where each weight comes from.
Everything with a superscript of 1 comes from our model&#x27;s first layer.
Here&#x27;s the equation for the first neuron in our second layer.
(0:09:52)</p><p>If we pass the outputs of our first layer directly into our second layer, this is equivalent to plugging in our first set of equations into our second equation, like this.
Distributing and collecting terms, we end up with a new constant times our input x1, plus another new constant times our input x2, plus this final constant.
This equation has the same shape as our individual neuron equations, just with different constants.
(0:10:18)</p><p>This result tells us that if we just hook up the outputs of one layer of plane-fitting neurons to the inputs of our next layer, we end up adding together different tilted planes, which just results in a different tilted plane.
So a two-layer network connected like this is still only capable in practice of fitting two planes to our map, just as our single-layer model did.
(0:10:40)</p><p>For our multi-layer neural network to be able to learn more complex patterns, we need to add one more small piece of math.
We&#x27;ll pass the output of our planes from our first layer into a function called an activation function that will modify their shape into something more complex for our model to work with.
It turns out that we can build high-performing neural networks using a variety of activation functions.
(0:11:03)</p><p>But one of the simplest and most widely used today is a function called a rectified linear unit, or ReLU. ReLU is incredibly simple.
For input values less than 0, ReLU returns 0. And for input values greater than or equal to 0, ReLU simply passes its input value through.
So ReLU of minus 1 is 0, and ReLU of 1 is 1. Applying our ReLU activation function to the output planes of our first layer, the regions of our plane with heights less than 0 are folded up or clipped to a height of 0. So instead of outputting planes, the first layer of our network now outputs these bent planes.
(0:11:42)</p><p>This is the folding operation we saw at the beginning of the video.
(0:11:46)</p><hr><p>So to decide which country a point is in, for example this Belgium point with coordinates of 0.6, 0.4 that we saw earlier, we pass these coordinates into our first layer of neurons, and get values of minus 0.14 and minus 0.33 out, corresponding to the height of each of our planes at the input coordinates of our point.
From here we apply our ReLU activation function, folding all values below 0 up to 0. The height of our point on both planes is negative, so we set both points to 0. So our input point 0.6, 0.4 has now been mapped to values of 0, 0 by our bent planes.
(0:12:25)</p><p>From here our final layer of neurons multiplies these values of 0, 0 by its weights, and adds its bias terms.
Shifting our combined bent planes up and down, moving our point to 0.03 on our top surface, and minus 0.89 on our bottom surface.
Our second neuron&#x27;s output corresponds to our model&#x27;s confidence in Belgium, which is higher in this case, meaning this point will be classified as being in Belgium. And visually we see this point on our Belgium plane being above our point on our Netherlands plane.
(0:12:57)</p><p>We can do a similar analysis for a point in the Netherlands, like this point at 0.3, 0.7. The key difference here is that this point does not fall in the 0 ReLU region of our second neuron, meaning that it gets pushed up on our final Netherlands bent plane, and pushed down on our final Belgium plane, resulting in a correct Netherlands classification.
So our bent plane geometry is equivalent numerically to moving data through our network, but gives us a nice way to see how all of the points on our map are processed at once.
(0:13:30)</p><p>As we add more neurons to our first layer, we&#x27;re able to make more and more folds in our map, cutting our map into more and more regions for our output neurons to push up and down into more and more complex surfaces.
Now, as we saw at the opening of the video, assuming a sufficient number of neurons in our first layer, the Universal Approximation Theorem tells us that a two-layer neural network exists that can represent the borders of our town at arbitrarily high precision.
(0:13:57)</p><p>But as we saw, even at 100,000 neurons in our first layer, we were not able to successfully train a model to completely match our borders.
What is going on here?
The Universal Approximation Theorem is sometimes mistaken to mean that neural networks can learn anything.
But what it really says is that a wide enough neural network is capable of representing any continuous function.
Now, the borders of our town are actually not continuous, but the continuity that the theorem is referring to here is actually the continuity of the final surfaces that we intersect to find our border.
(0:14:33)</p><p>The real issue here is that although the Universal Approximation Theorem tells us that a two-layer solution exists, it does not mean that in practice we can actually find the solution.
(0:14:44)</p><hr><p>And the theorem does not tell us how many neurons we actually need to solve a given problem.
As we saw in parts 1 and 2 of this series, modern neural networks learn using backpropagation and gradient descent, which provide no guarantees of finding the best or even a good solution.
Instead, these algorithms make small iterative updates to our parameters.
And we typically just stop the learning process when performance stops improving.
(0:15:10)</p><p>Before training, our network is randomly initialized, placing our fold lines at random locations on our map.
Here&#x27;s one initialization for our five-neuron, two-layer model.
Here&#x27;s how our folded planes are combined by the second layer of this model.
And here&#x27;s how these surfaces intersect to form a decision boundary before training.
If we pass in the Belgian point we considered earlier into our randomly initialized model, this point ends up on this planar region in our second layer&#x27;s surface.
(0:15:39)</p><p>This first neuron surface ends up on top in our final output, shown here in blue, meaning that our model incorrectly classifies our point as being in the Netherlands. This error is measured using the cross-entropy loss, as we saw in part 2. And this loss is then run through our backpropagation algorithm, resulting in gradient values for each of our model&#x27;s 17 parameters.
Some of the largest resulting gradients are for this third neuron in our first layer.
(0:16:06)</p><p>Both our DLDM31 and our DLDB3 gradients are large and negative.
Currently, M31 is negative, tilting our plane down in the X1 direction.
Our gradient is telling us that to decrease our loss, we should increase M31, which will reduce the slope of our plane, making it flatter.
Backpropagation also returns a large negative value for DLDB3, which tells us to shift our whole plane upwards.
(0:16:36)</p><p>Adjusting our parameters in this direction moves our plane, and shifts our ReLU joint line to the right.
Zooming out to our full network, we can see how this update moves the center fold line in our second layer to the right.
On our final surfaces, our update moves our top blue surface down, reducing the model&#x27;s confidence in the incorrect answer of the netherlands, while moving our decision boundary to the right.
(0:17:02)</p><p>We can now repeat this gradient descent process, and watch our model learn.
Step by step, these small updates adjust both the locations of the fold lines in our first layer, and the way these bent planes are combined by our second layer, until we have a nice concave down surface on top of Belgium, that intersects a concave up netherlands surface at a nice border.
(0:17:24)</p><p>Now, when I initially tried to train this model, it didn&#x27;t actually work nearly this well.
I had a different random initialization that looked more like this, placing our blue surface on top of our yellow surface, when we want our model to learn the exact opposite orientation, with a central yellow region for Belgium on top.
As our model learns from this starting point, our backpropagation algorithm begins to reverse the orientation of these surfaces, lowering our loss values, and moving the blue surface down and the yellow surface up.
(0:17:57)</p><p>But in doing so, backpropagation pushes the decision boundaries off of our planes, leaving our whole town in the zeroed out part of our bent ReLU plane.
(0:18:06)</p><hr><p>Gradient descent is not able to recover from this configuration, since the gradients through the zeroed out part of our ReLU activation function are also zero, leaving our model with effectively a single plane to work with, resulting in a suboptimal linear decision boundary.
So even though we know that a nice solution exists for our 5-neuron network, given this starting point, gradient descent is not able to find it.
(0:18:31)</p><p>In the case of our super-wide 100,000-neuron network, there may be analogously good solutions out there, we just can&#x27;t reach them with gradient descent.
Now, there is some subtlety here.
As we saw back in part 1, when models become large, the chances of gradient descent actually getting stuck in a local minimum in this high-dimensional loss landscape becomes very small.
Our super-wide network is probably not getting stuck in quite the same way as our small network.
(0:19:00)</p><p>In addition to not telling us how to find a specific solution, the universal approximation theorem also does not tell us how many neurons we actually need to solve a given problem.
And in fact, for a broad class of functions, it&#x27;s been shown that the number of neurons we need in a shallow network is exponentially larger than the number of neurons needed in a deep network.
(0:19:22)</p><p>So it&#x27;s possible that 100,000 neurons may actually not be enough.
Finally, it&#x27;s difficult to prove a negative.
In the course of making this video, I experimented with a bunch of different optimizer configurations for these wide models.
But it wouldn&#x27;t surprise me if there&#x27;s a way to train a 100,000 neuron, a 10,000 neuron, or maybe even smaller two-layer model to fit the borders of our town.
(0:19:44)</p><p>I&#x27;ll leave a link to my code in the description if you want to experiment.
And please send me your results if you make progress. I would love to see a solution.
Exact number of neurons aside, as we saw earlier, we can make incredible efficiency gains by going deep instead of wide, stacking our neurons into additional layers.
And that&#x27;s what we&#x27;ll turn our attention to next.
(0:20:04)</p><p>What new geometry does stacking our layers create?
And how does this geometry help our model learn the complex borders of our town?
Let&#x27;s begin with a simple two-layer model with two neurons each.
This simple two-layer model learns these folds in our map, which are combined by our second layer into this bent-up surface and this bent-down surface.
Taking the intersection of our surfaces, where our model is equally confident in both countries, we get this simple decision boundary.
(0:20:33)</p><p>Now, let&#x27;s add a third layer to our model with two additional neurons.
So we now have three layers and six neurons total.
After training, our first layer learns to fold our input planes like this, and our second layer learns to combine our bent planes like this.
Now, if we only had two layers, we would just bring these surfaces together to form our final decision boundary.
(0:20:56)</p><p>But we now have a whole additional layer of transformations to apply.
(0:21:00)</p><hr><p>Just as we did in our first layer, we now need to apply our ReLU activation function, where all of the values on our surface with heights less than zero are set to zero.
In our first layer, this operation folds our planes along linear fold lines.
But now in the second layer of our model, the surfaces we&#x27;re folding are no longer simple planes.
If we add a plane at z equals zero to our first neuron surface, we can see that this surface actually has three separate planes that all cross z equals zero.
(0:21:31)</p><p>When we apply our ReLU activation function and fold up our surface, we create three separate new fold lines, one for each region that crosses the z equals zero plane.
And interestingly, these folds are not at the same angle, but actually bend at the joints of the planes we get from our first layer.
So here a single neuron is able to make three separate folds, with fairly complex geometries.
(0:21:56)</p><p>Our second neuron in our second layer applies the same operations, but with different learned weights, resulting in these three new folds.
Now, just as our previous two layers did, our third and final layer scales and adds our new surfaces together.
After our first layer, the combination of our two ReLU folds created four regions for the next layer of our model to work with.
(0:22:21)</p><p>These are easiest to see in a 2D projection like this.
Stacking the new fold lines from our second layer, these new folds at various angles come together in a significantly more complex tiling of our map, with these ten separate regions.
When the final layer of our network scales and adds together the outputs of our second layer, the resulting surfaces are composed of the same ten regions, just with different heights.
(0:22:46)</p><p>The height of these surfaces corresponds to the model&#x27;s final confidence in our two countries.
Bringing these surfaces together and finding their intersection, we get this final decision boundary, which shows some nice piecewise linear curvature around the Belgian regions of our map.
So the first layer of our network creates these two folds and four separate regions on our map, which are then split by our second layer into these ten regions, which are used by our final layer to create these surfaces, which intersect in a nice border.
(0:23:18)</p><p>The fact that just adding two additional neurons takes our map from these four regions to these ten is remarkable to me, especially considering the complex geometry of these ten regions.
If we instead arrange our six neurons in a two-layer network like this, our model learns to fold four copies of our map like this, resulting in these seven regions, these surfaces, and this final decision boundary.
(0:23:43)</p><p>This decision boundary isn&#x27;t necessarily worse than the one learned by our deeper model, but I&#x27;m particularly struck by how much more complex the tiling learned by our deeper model is.
Qualitatively, the tiling of our map learned by our shallow network feels very much like we&#x27;ve just stacked four lines together, which is exactly what we&#x27;ve done.
(0:24:03)</p><hr><p>While the tiling learned by our deeper model feels to me like something entirely different.
By repeating our folding, scaling, and combining operations, these operations are able to compound on themselves, allowing the neurons in our second layer to generate significantly more complex patterns than they would if they were instead positioned in the first layer of our model.
The compounding analogy is not a coincidence.
(0:24:28)</p><p>It turns out that we can show that the maximum number of regions a ReLU network like ours can divide our map into grows exponentially with the number of layers in our network.
This equation gives the theoretical maximum number of regions our model can create as a function of the number of neurons in each layer, d, the number of inputs, d sub i, and the number of layers in our network, k, not including our final output layer.
(0:24:53)</p><p>Plugging in d equals two neurons per layer, d sub i equals two inputs, and k equals two layers, we get 2 squared times 4 equals 16 total possible regions for our model.
This is a bit above the 10 regions our model actually learned.
If we add another two-neuron layer to our model, our number of regions grows to 2 to the power of 4 times 4 equals 64. And adding another layer gets us to 256 and so on.
(0:25:20)</p><p>So each layer theoretically quadruples the number of regions our model can create in this configuration.
This final polynomial part of the equation captures what happens in the final layer of our model.
If we cut back down to a shallow two-layer model, k becomes 1, eliminating the exponential growth term.
As we&#x27;ve seen, two-layer networks divide up the input plane by stacking separate ReLU folds.
(0:25:46)</p><p>So finding the number of regions we can divide our map into with a two-layer network is equivalent to asking how many separate regions we can split a plane into with d lines.
This is a well-known result in combinatorial geometry with the answer given by this polynomial.
So our theory tells us that the maximum number of regions we can create with a two-layer network grows as a polynomial function of our number of neurons, while the number of regions we can create with a deeper network grows exponentially with the number of layers.
(0:26:18)</p><p>Placing 64 neurons in the first layer of a two-layer network like this results in a maximum of 2,081 possible regions, while rearranging these neurons into four layers instead results in a theoretical maximum of over 70 million possible regions.
The difference between these growth rates is compelling and is often pointed to as a reason for the effectiveness of deep learning.
However, these numbers are theoretical upper bounds, and as a number of papers have pointed out, these bounds are very loose.
(0:26:48)</p><p>In practice, we typically do not see exponential growth in the number of regions created by deep networks as we add layers.
Let&#x27;s scale up our own deep network and see how our number of regions scales with our network and how our fit improves.
(0:27:02)</p><hr><p>We left off with this three-layer, six-neuron model that divided our map into these ten regions, resulting in this final decision boundary.
Let&#x27;s first expand our model to have eight neurons in each of our first two layers.
The eight folds in our first layer now break up our map into these 19 regions.
And the various folds of the surfaces created by our second layer come together in these 102 regions.
(0:27:28)</p><p>Our second layer patterns start to get really interesting.
Here, the ReLU function in our second neuron is folding our surface along ten different unique joints.
Our final layer scales and combines these outputs into these final surfaces, which intersect like this, resulting in this final decision border, capturing the two largest sections of our town nicely.
Note that a couple of the neurons in our second layer don&#x27;t have any colored regions.
(0:27:56)</p><p>This means that the entire surface from our first layer was below z equals zero, and all inputs are set to zero by our ReLU activation function.
Dead neurons like this are common, and a reminder that gradient descent gives no guarantees about efficiently using our model architecture.
Let&#x27;s add another eight-neuron layer to our model, resulting in four total layers.
We can now really start to see the compounding effects of our repeated folding, scaling, and combining operations.
(0:28:26)</p><p>The ReLU folding happening in this third neuron of our third layer creates these tiny regions around the border.
It&#x27;s so interesting to me that our model, guided by backpropagation, figures out how to create all these extra little polygons around our town&#x27;s borders to capture their detailed structure.
Now, at this scale, it becomes tough to make sense of everything that&#x27;s happening in 3D space like this.
(0:28:50)</p><p>Let&#x27;s focus on the regions formed on our 2D map by each layer, the final 3D surfaces, and our final decision boundary.
Let&#x27;s watch our model learn from this perspective.
Before training, here&#x27;s how our model initially divides up our input space, creating this decision boundary.
Before we start the training process, let&#x27;s add one more panel that will track the model&#x27;s loss as it learns.
(0:29:12)</p><p>In less than 100 gradient descent steps, our model is able to pick out the core structure of our town and then is able to progressively tighten its borders as it learns, creating more and more regions around the fine details of the border.
Finally, let&#x27;s add one more layer, bringing our total number of layers to five, and increase our width one last time to 32 neurons.
(0:29:38)</p><p>Our additional layer gives us one more tiling of our map.
And at this scale, our 3D plot becomes a bit too chaotic to make sense of.
So we&#x27;ll just watch the 2D plots in this final training animation.
Unlike our smaller models, this deeper model really benefits from more training steps, using the extra steps to refine the details of our town&#x27;s border.
The fact that just four layers with 32 neurons each can learn this level of complexity is remarkable to me.
(0:30:07)</p><p>Our final decision boundary impressively captures every region of our town.
(0:30:11)</p><hr><p>It&#x27;s incredible to me that a bunch of little linear models can come together to do something so complex, and that we can actually find these solutions using gradient descent.
Around ten years ago, I released the very first Welch Labs video.
It&#x27;s called Neural Networks Demystified. Like the series you&#x27;re watching now, Neural Networks Demystified was a series about how neural networks learn, focusing on backpropagation and gradient descent.
(0:30:40)</p><p>Sitting down to work on this series ten years later, I honestly didn&#x27;t know where to start.
Although most of the core approaches in my old videos are unchanged, these core ideas have been scaled to solve unbelievably complex problems.
And this shocking ability to scale has led the research community to dig deeper into what makes these models tick.
We&#x27;ve learned a great deal in ten years, but many mysteries remain.
(0:31:05)</p><p>In part one of this series, we dug into lost landscapes, and we saw how the standard mental picture of gradient descent that I presented ten years ago really doesn&#x27;t hold up in the incredibly high-dimensional spaces these models operate in.
In part two, we dug into the core mechanics of how models learn, dissecting backpropagation in the context of a modern large-language model.
Finally, in this video, we saw how deep models are able to recursively fold, scale, and combine their input spaces, learning incredibly complex patterns with remarkably few neurons.
(0:31:38)</p><p>Maybe in another ten years, I can make another series like this.
We&#x27;ll have to wait and see what these models can do then, and how much sense we&#x27;ll be able to make of how they do it.
Back in 2019, I completely quit Welch Labs. I had just tried going full-time creating videos, but I wasn&#x27;t able to earn enough money to make it work.
(0:32:00)</p><p>I got frustrated, and I quit.
I went off and worked as a machine learning engineer, which was great, but I couldn&#x27;t shake the feeling that I was really supposed to be making videos.
Starting in 2022, I slowly eased back on TikTok, and was able to gradually build enough momentum to take another crack at going full-time last year.
When I quit in 2019, I had some time to really think about what kept pulling me back into making videos.
(0:32:24)</p><p>And I realized that deep down, it was really about education.
I loved math and science as a kid, but I really disliked the way I had to learn it in school.
After undergrad, I really found myself questioning if I even liked math at all.
Only through my own work and study did I fall back into love with math and science years later.
And now, I want to use Welch Labs to make education better.
(0:32:46)</p><p>But I&#x27;ve realized, for me to be able to do this, I have to first build a viable business.
If I can&#x27;t support myself and my family, I can&#x27;t spend the time I need to make this work.
Last year, through sponsorships, poster and book sales, and support on Patreon, I was able to make about half of what I made as a machine learning engineer.
(0:33:05)</p><p>I&#x27;m not going to lie, so far this is a much harder way to earn a living.
(0:33:09)</p><hr><p>My goal this year is to replace my full income.
This will allow me to really reach escape velocity and continue full time on Welch Labs. Sponsorships, posters, and book sales are going well this year.
But to hit my goal, I need to grow Patreon as well.
Your monthly support on Patreon would mean a lot.
As a way to say thank you, today I&#x27;m launching a new reward.
(0:33:31)</p><p>Starting at the $5 per month level, I&#x27;ll send you a real paper cutout used in a Welch Labs video.
It comes in a nice protective sleeve with the Welch Labs logo on the front, and on the back it says the video it came from, the release date, and a sign by me.
These are a lot of fun.
(0:33:49)</p><p>I have them going all the way back to 2017. At the $5 per month level you&#x27;ll receive a smaller cutout, and a larger cutout at the $10 or higher level.
Cutouts ship after your first monthly payment goes through, and you&#x27;ll find a link to the Welch Labs Patreon in the description below.
Huge thank you to everyone who&#x27;s supported Welch Labs over the years.
(0:34:06)</p><p>Thanks for watching.
(0:34:07)</p></div></div></details></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>タグ:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a title="AI" class="tag_zVej tagRegular_sFm0" href="/ds/blog/tags/AI">AI</a></li><li class="tag_QGVx"><a title="2025-08" class="tag_zVej tagRegular_sFm0" href="/ds/blog/tags/2025-08">2025-08</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="ブログ記事のナビゲーション"><a class="pagination-nav__link pagination-nav__link--prev" href="/ds/blog/2025/08/10/ja_fatima"><div class="pagination-nav__sublabel">新しい記事</div><div class="pagination-nav__label">Jimmy Akin : Fatima の奇跡 とカトリック教会</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/ds/blog/2025/08/09/dimuro_farm"><div class="pagination-nav__sublabel">過去の記事</div><div class="pagination-nav__label">2002-07, アルゼンチン : Jumeiro 農場での怪奇現象 ⇒ この謎を解く</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前置き" class="table-of-contents__link toc-highlight">前置き</a></li><li><a href="#概要" class="table-of-contents__link toc-highlight">概要</a></li><li><a href="#目次" class="table-of-contents__link toc-highlight">目次</a></li><li><a href="#音声対話" class="table-of-contents__link toc-highlight">音声対話</a></li><li><a href="#詳細" class="table-of-contents__link toc-highlight">詳細</a><ul><li><a href="#1-ユニバーサル近似定理とその限界" class="table-of-contents__link toc-highlight">1. ユニバーサル近似定理とその限界</a></li><li><a href="#2-深層ネットワークの優位性" class="table-of-contents__link toc-highlight">2. 深層ネットワークの優位性</a></li><li><a href="#3-ニューラルネットワーク研究の進化と教育への貢献" class="table-of-contents__link toc-highlight">3. ニューラルネットワーク研究の進化と教育への貢献</a></li><li><a href="#結論" class="table-of-contents__link toc-highlight">結論</a></li></ul></li><li><a href="#普遍的近似定理" class="table-of-contents__link toc-highlight">普遍的近似定理</a><ul><li><a href="#普遍的近似定理の定義とその保証" class="table-of-contents__link toc-highlight">普遍的近似定理の定義とその保証</a></li><li><a href="#理論と実践のギャップ" class="table-of-contents__link toc-highlight">理論と実践のギャップ</a></li><li><a href="#ディープネットワークの利点と効率性" class="table-of-contents__link toc-highlight">ディープネットワークの利点と効率性</a></li></ul></li><li><a href="#ニューラルネットワークの幾何学的解釈" class="table-of-contents__link toc-highlight">ニューラルネットワークの幾何学的解釈</a><ul><li><a href="#1-浅い2層ニューラルネットワークの幾何学的解釈" class="table-of-contents__link toc-highlight">1. 浅い（2層）ニューラルネットワークの幾何学的解釈</a></li><li><a href="#2-深い多層ニューラルネットワークの幾何学的解釈" class="table-of-contents__link toc-highlight">2. 深い（多層）ニューラルネットワークの幾何学的解釈</a></li></ul></li><li><a href="#浅いネットワークと深いネットワークの対比" class="table-of-contents__link toc-highlight">浅いネットワークと深いネットワークの対比</a><ul><li><a href="#ワイドネットワーク浅い2層ニューラルネットワークの幾何学的解釈と限界" class="table-of-contents__link toc-highlight">ワイドネットワーク（浅い2層ニューラルネットワーク）の幾何学的解釈と限界</a></li><li><a href="#ディープネットワーク多層ニューラルネットワークの幾何学的解釈と優位性" class="table-of-contents__link toc-highlight">ディープネットワーク（多層ニューラルネットワーク）の幾何学的解釈と優位性</a></li><li><a href="#ワイドネットワークとディープネットワークの比較" class="table-of-contents__link toc-highlight">ワイドネットワークとディープネットワークの比較</a></li></ul></li><li><a href="#学習プロセスと課題" class="table-of-contents__link toc-highlight">学習プロセスと課題</a><ul><li><a href="#学習プロセス" class="table-of-contents__link toc-highlight">学習プロセス</a></li><li><a href="#学習の課題と限界" class="table-of-contents__link toc-highlight">学習の課題と限界</a></li></ul></li><li><a href="#情報源" class="table-of-contents__link toc-highlight">情報源</a><ul><li><a href="#動画概要欄" class="table-of-contents__link toc-highlight">動画概要欄</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">最新更新：2025-07-12, サイト管理者：ume2509, Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>